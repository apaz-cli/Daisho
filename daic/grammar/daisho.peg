%node PROG
program    <- sh:SHEBANG? implicit:BLK

/**************************/
/* TOP LEVEL DECLARATIONS */
/**************************/

ctype      <- CTYPE CIDENT STAR*

cfunc      <- CFUNC CIDENT

traitdecl  <- TRAIT id:TIDENT (IMPL)?
              LCBRACK
              RCBRACK

impldecl   <- IMPL tt:TIDENT FOR ft:TIDENT
              LCBRACK
              RCBRACK

tmpldecl   <-

fndecl     <-

fnproto    <-

fnarglist  <-

type       <- TIDENT       // Type identifier
            / TIDENT GRAVE // Trait object (+1 pointer, trait)
            / type STAR    // Pointer type (+1 pointer)


/****************************/
/* CONTROL FLOW EXPRESSIONS */
/****************************/



/***************/
/* EXPRESSIONS */
/***************/

expr <- next


/********************/
/* BINARY OPERATORS */
/********************/

%rule LOGOR
%rule LOG
%rule OR
%rule XOR
%rule AND
logorexpr  <- n:next {rule=n} (op:LOGOR  n:next {rule=node(LOGOR,  op, rule, n)})*
logandexpr <- n:next {rule=n} (op:LOGAND n:next {rule=node(LOGAND, op, rule, n)})*
binorexpr  <- n:next {rule=n} (op:OR     n:next {rule=node(OR,     op  rule, n)})*
binxorexpr <- n:next {rule=n} (op:XOR    n:next {rule=node(XOR,    op, rule, n)})*
binandexpr <- n:next {rule=n} (op:AND    n:next {rule=node(AND,    op, rule, n)})*


%rule DEQ
%rule NEQ
%rule BEQ
eneqexpr   <- n:next {rule=n}
             (op:(DEQ / NEQ)
              n:next {rule=node(BEQ, op, rule, n)})*


%rule LT
%rule GT
%rule LEQ
%rule GEQ
%rule CMP
cmpexpr    <- n:next {rule=n}
             (op:(LT / GT / LEQ / GEQ)
              n:next {rule=node(CMP, op, rule, n)})*


%node SHF
shfexpr    <- n:next {rule=n}
             (op:(lshf / rshf) // Tokenized as << and >>. See the rule.
              n:next {rule=node(SHFEXPR, op, rule, n)})*


%node FACTOR
%node MUL
%node DIV
%node MOD
multexpr   <- n:next {rule=n}
             (op:(MUL / DIV / MOD)
              n:next {rule=node(FACTOR, op, rule, n)})*


%node SUM
%node PLUS
%node MINUS
sumexpr    <- n:next {rule=n}
             (op:(PLUS / MINUS)
              n:next {rule=node(SUM, op, rule, n)})*

/* (Cast) (Call) */
castexpr   <- o:OPEN t:type CLOSE e:expr { rule = node(o, t, e); }
            / re:refexpr { rule = re; }

/* @ $ */
refexpr    <- d:derefexpr a:AT? { rule = a != SUCC ? node(REFEXPR, a, d) : d }
derefexpr  <-


/*********/
/* ATOMS */
/*********/

atomexpr   <- VIDENT
            / NUMLIT
            / STRLIT
            / blockexpr
            / castexpr
            / lambdaexpr
            / listcomp
            / parenexpr


%node BLK
blockexpr  <- LCBRACK
              {rule=list(BLK)}
              (e:expr {add(rule, e)})*
              RCBRACK


%node LAMBDA
lambdaexpr <-
listcomp   <-

parenexpr  <-

/**********************/
/* MISC GRAMMAR STUFF */
/**********************/

%node LSHF
%node RSHF
lshf    <- l1:LT l2:LT {rule=node(LSHF l1, l2)})}
rshf    <- g1:GT g2:GT {rule=node(LSHF g1, g2)})}
