/**************************/
/* TOP LEVEL DECLARATIONS */
/**************************/

ctype      <- 

cfunc      <- CFUNC 

traitdecl  <- TRAIT id:TIDENT (IMPL)?
              LCBRACK
              RCBRACK
              
impldecl   <- IMPL tt:TIDENT FOR ft:TIDENT
              LCBRACK
              RCBRACK

fndecl     <- 

fnproto    <-

fnarglist  <-

type       <- TIDENT
            / TIDENT GRAVE
            / type STAR


/****************************/
/* CONTROL FLOW EXPRESSIONS */
/****************************/



/***************/
/* EXPRESSIONS */
/***************/

expr       <- e:commaexpr {node=e}

/* then also = += ?: */
taexpr     <- eq:eqexpr     (ta:(THEN / ALSO) ex:expr { rule = com ? node(com, eq, ex)   : eq; })*
eqexpr     <- te:ternexpr   (eq:EQ ex:expr)?                  { rule = eq  ? node(eq, te, ex)    : te; }
ternexpr   <- le:logorexpr  (q:QUEST _e:expr? COLON ex:expr)? { rule = q   ? node(q, le, _e, ex) : le; }

/* Lambda expression */

/* || && | ^ & */
logorexpr  <- la:logandexpr (lo:LOGOR ex:expr)?               { rule = lo  ? node(lo, la, ex)    : la; }
logandexpr <- bo:binorexpr  (an:LOGAND ex:expr)?              { rule = an  ? node(an, bo, ex)    : bo; }
binorexpr  <- bx:binxorexpr (or:OR ex:expr)?                  { rule = or  ? node(or, bx, ex)    : bx; }
binxorexpr <- ba:binandexpr (xor:XOR ex:expr)?                { rule = xor ? node(xor, ba, ex)   : ba; }
binandexpr <- de:deqexpr    (and:AND ex:expr)?                { rule = and ? node(and, de, ex)   : de; }

/* == != */
eneqexpr   <-

/* < > <= >= */
cmpexpr    <-

/* << >> */
%node LSHFEXPR
%node RSHFEXPR
shfexpr   <-

/* * / % */
%node MULEXPR
%node DIVEXPR
%node MODEXPR
mulexpr    <-
divexpr    <-
modexpr    <-

/* + - */
addexpr    <-
subexpr    <-

/* (Cast) (Call)*/
castexpr   <- o:OPEN t:type CLOSE e:expr { rule = node(o, t, e); } / re:refexpr { rule = re; }

/* @ $ */
refexpr    <- d:derefexpr a:AT? { rule = a != SUCC ? node(REFEXPR, a, d) : d }
derefexpr  <- 

/* atoms */
%node BLKEXPR
atomexpr   <- blockexpr
            / lambdaexpr
            / listcomp
            / VIDENT
            / NUMLIT
            / STRLIT

blockexpr  <- LCBRACK
              {rule=list(BLKEXPR)}
              (e:expr {add(rule, e)})*
              RCBRACK
lambdaexpr <- 
listcomp   <-

/**********************/
/* MISC GRAMMAR STUFF */
/**********************/

typelit <- TIDENT
strlit  <- STRLIT
numlit  <- NUM
